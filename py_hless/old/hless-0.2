#!/usr/bin/python -O
#
# Copyright 2010 Alexander Sandler
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

hless_version = '0.2'

man = """
.\" MAN STARTS HERE
.\\"Text automatically generated by txt2man
.TH hless 1 "17 October 2010" "hless" "Alexander Sandler"
.SH NAME
\\fBhless
\\fB
.SH SYNOPSIS
.nf
.fam C
\\fBhless\\fP \\fIinfile\\fP

.fam T
.fi
.fam T
.fi
.SH OPTIONS
h - Shows \\fBhless\\fP manual page.
.SH COMMANDS
.TP
.B
There is a number of commands that can be executed while in \\fBhless\\fP. Each command has a key binding
used to invoke the command. Below is a list of commands with description of what each one of them 
does.
.SS SEARCHING
\\fBhless\\fP allows you to specify up to four different search patterns. There's a main search pattern 
slot. Matches of main pattern marked with black on white color. In addition, there are three more 
search patterns slots: red, green and blue search patterns. Matches of each of these patterns marked 
with red, green or blue colors respectively.
.PP
Each search pattern can be searched both upward and downward. Each pattern has a default search 
direction. Once search direction is set, \\fBhless\\fP will continue searching in this direction. Search 
direction can be flipped for main search pattern.
.PP
/ - Search forward (pops edit box). Search direction set to downwards.
.br
? - Search backwards (pops edit box). Search direction set to upwards.
.br
n - Find next match of main pattern. Search direction is the same as original search.
.br
N - Find previous match of the main search pattern. Seach direction is opposite to original search.
.br 
F - Flip search direction of the main search pattern.
.br
~ - Reset main search pattern. This actively cancels the main search, hiding all matches from 
both the screen and the memory.
.br
\\\\ - Opens Search Patterns Menu
.PP
.B ADDITIONAL SEARCH PATTERNS
.br
Additional three search patterns are available from Search Patterns Menu. Below is a list of options 
available in the menu with their respective meaning.
.IP \\(bu 3
Push current search - Pushes main search pattern into next available search pattern slot (red,
green or blue).
.IP \\(bu 3
Force push current search - Pushes main search pattern into selected search pattern slot. This
option presents a menu that allows you to choose what slot to use. Search pattern in the target slot 
will be reset
.IP \\(bu 3
Pop selected search - Moves selected search pattern to main search slot. If main search pattern
slow is occupied, this will overwrite the main search pattern.
.IP \\(bu 3
Exchange current and selected search - Exchanges between one of the red, green or blue search
patterns with main search pattern.
.IP \\(bu 3
Delete selected search - Resets selected slot, deleting its search pattern and matches.
.IP \\(bu 3
Delete all searches - Deletes all search patterns. Will not touch main search pattern.
.SS MATCH PATTERNS
\\fBhless\\fP allows you to specify what lines of text to leave visible on screen. This is done using so 
called match patterns.
.PP
Once you configure a match pattern, \\fBhless\\fP will show only lines that match the pattern. In case there 
are several match patterns, \\fBhless\\fP will show lines that match all configured patterns.
.PP
Following keyboard commands manipulate match patterns.
.PP
s - Add new match pattern.
.br
S - Show Match pattern operations menu
.SH AUTHOR
Alexander Sandler <alex@alexonlinux.com>
.br
Submit bugs reports at http://git.alexonlinux.com/projects/\\fBhless\\fP
.br
For more information, see \\fBhless\\fP home page at 
.br
http://www.alexonlinux.com/\\fBhless\\fP
.\" MAN ENDS HERE
"""

help = """
    Keyboard shortcuts:
    
    q - quit                                   h - show this screen
    
    / - search downwards                       g - goto beginning of the file
    ? - seach upwards                          G - goto end of the file
    n - goto next search match                 l - show line numbers
    N - goto previous search match             : - goto line
    F - flip search direction                  ~ - cancel search
    \ - show search set operations menu
    1 - goto next red slot search match        ! - goto previous red slot search match
    2 - goto next green slot search match      @ - goto previous green slot search match
    3 - goto next blue slot search match       # - goto previous blue slot search match
    
    s - add pattern to match list              d - add pattern to hide list
    S - show match pattern operations menu     D - show hide pattern operations menu
    
    . - goto next mark                         > - goto previous mark
 *  c - mark all matchings lines with selected color
 *  C - color operations menu
    
    p - save current settings in profile   P - load selected profile
    
    t - toggle tail -f mode (hless will follow to end of file and reopen if necessary)
    
    i - show inventory (search, hide, match and other patterns)
 *  I - open notepad
    
    Z - start debug logs
    
"""

import bisect
import curses
import curses.ascii
import fcntl
import logging
import os
import re
import struct
import sys
import termios
import datetime
import threading
import time
import signal
import optparse
import types
from pprint import pformat, pprint
import select
import gzip
import traceback
import copy
import subprocess
import cStringIO

hless = None

class Log:
	first_time = True
	enabled = False
	
	debug_groups = []
	groups = ['main', 'brush', 'editbox', 'search', 'screen', 'keys', 'navigate', 'buffer', 'debug', 'menu']
	
	main = logging.getLogger('main')
	brush = logging.getLogger('brush')
	search = logging.getLogger('search')
	editbox = logging.getLogger('editbox')
	screen = logging.getLogger('screen')
	keys = logging.getLogger('keys')
	navigate = logging.getLogger('navigate')
	buffer = logging.getLogger('buffer')
	debug = logging.getLogger('debug')	
	menu = logging.getLogger('menu')
	
def SetupLogs():
	if not Log.first_time:
		return
		
	Log.first_time = False

	logging.basicConfig(
		format = '%(asctime)s %(name)8s %(levelname)s: %(message)s', \
		filename = 'log.txt', \
		filemode = 'w')
	
	for group in Log.groups:
		logging.getLogger(group).setLevel(logging.INFO)
	
	if 'all' in Log.debug_groups:
		for group in Log.groups:
			logging.getLogger(group).setLevel(logging.DEBUG)
	else:
		for group in Log.debug_groups:
			logging.getLogger(group).setLevel(logging.DEBUG)
			
def KeyName(c):
	if c >= 0:
		return curses.keyname(c)
	else:
		return 'invalid key'
	
def FormatException(ex = None):
	res = ''
	if ex != None:
		res += str(ex) + '\n'
	res += traceback.format_exc()
	return res

class Config:
	STATUS_BAR_HEIGHT = 2

	file = None
	filename = ''
	stdin = None

	tab_width = 4
	
class StdinFile:
	def __init__(self):
		self.bytes = 0
		self.file = os.fdopen(os.dup(0), 'r')
		self.pos = 0
		
	def __has_something_to_read(self):
		"""read()s are blocking, mostly. To avoid blocking on read() we would like to
		know if there's something to read before we read(). This routine does exactly this - 
		it checks if there's something to read."""
		r, w, e = select.select([self.file], [], [], 0)
		if Log.enabled: Log.buffer.debug('There are %d items in read list', len(r))
		if len(r) == 0:
			if Log.enabled: Log.buffer.info('Reached end of file')
			return False
		else:
			return True	
		
	def read(self, *args, **kw):
		res = ''
		if self.__has_something_to_read():
			res = self.file.read(*args, **kw)
			if Log.enabled: Log.buffer.debug('Read %d bytes from StdinFile', len(res))
			self.pos += len(res)
		return res
		
	def readline(self, *args, **kw):
		res = ''
		if self.__has_something_to_read():
			res = self.file.readline(*args, **kw)
			if Log.enabled: Log.buffer.debug('Read %d bytes from StdinFile', len(res))
			self.pos += len(res)
		return res
		
	def seek(self, pos, whence = 1):
		# This is a hack that makes gzip to work with this file type.
		# gzip requires that file will support seek() and tell() in a certain way.
		# It saves current position in the file and changes it to end of file using
		# seek. Next it gets current position again and compares it with previous
		# position. If they match, this indicates that it has reached end of file.
		# Since this is a stdin file descriptor, it's always at the end of file. 
		# This little hack makes end of file to be at 4GB.
		# Thanks to this one can send compressed stream to hless's input and it will work.
		if whence == 2:
			self.pos = 1024 * 1024 * 1024 * 4 - pos
		else:
			self.pos = pos
		
	def tell(self):
		return self.pos
		
	def fileno(self, *args, **kw):
		return self.file.fileno(*args, **kw)
		
def SetupSystem():
	if Config.file == None:
		Config.stdin = StdinFile()
		os.close(0)
		os.open('/dev/tty', os.O_RDONLY)
		Config.file = Config.stdin
		
def ParseCommandLine():
	global hless_version
	
	parser = optparse.OptionParser(add_help_option = False)

	d_help = 'enables debug logs; argument is comma separated combination of any of the: '
	d_help += ', '.join(Log.groups) + ', all'
	
	parser.add_option('-D', '--debug', help = d_help, action = 'store', \
		dest = 'debug', default = '')
	parser.add_option('-v', '--version', help='prints hless\'s version number', action = 'store_true', \
		dest = 'version', default = False)
	parser.add_option('-h', help = 'shows hless man page', action = 'store_true', dest = 'show_man', default = False)
	
	(opts, args) = parser.parse_args()
	
	if opts.version:
		print 'hless - Text file viewer'
		print 'Version number: %s' % hless_version
		print 'Copyright 2010 Alexander Sandler'
		print 'This program is free software under terms and conditions of '
		print 'version 3 of GNU General Public License'
		sys.exit(0)

	if opts.show_man:
		print 'Writing man page...'
		fd = open('/tmp/hless.man', 'w+')
		fd.write(man)
		fd.close()
		subprocess.call(['man', '/tmp/hless.man'])
		sys.exit(0)
	
	if opts.debug != '':
		Log.enabled = True
		Log.debug_groups = opts.debug.split(',')
		SetupLogs()
	
	if len(args) != 0:
		Config.filename = args[0].strip()
		try:
			Config.file = open(Config.filename, 'r', 64 * 1024)
		except IOError:
			print 'Failed to open file'
			raise
	else:
		Config.filename = '<stdin>'

class Singleton(type):
	def __init__(cls, name, bases, dict):
		super(Singleton, cls).__init__(name, bases, dict)
		cls.instance = None

	def __call__(cls, *args, **kw):
		if cls.instance is None:
			cls.instance = super(Singleton, cls).__call__(*args, **kw)
		return cls.instance

class ProgressThread(threading.Thread):
	def __init__(self, progress_bar):
		threading.Thread.__init__(self)
		self.keep_running = True
		self.progress_bar = progress_bar
		self.stop_event = threading.Event()
		self.stop_event.clear()

	def run(self):
		last_progress = datetime.datetime.now() - datetime.timedelta(seconds = 2)
		while self.keep_running:
			if datetime.datetime.now() - last_progress > datetime.timedelta(milliseconds = 100):
				self.progress_bar.Draw()
				last_progress = datetime.datetime.now()
			self.stop_event.wait(0.1)
			
class GeometryAware:
	def __init__(self, scr, hless):
		self.scr = scr
		self.hless = hless
		self.max_y, self.max_x = self.scr.getmaxyx()

	def _recalc_geometry(self):
		height, width = self.scr.getmaxyx()
		if height == self.max_y and width == self.max_x:
			return False

		if self.max_y != 0 and self.max_x != 0:
			self.hless.NoteGeometryChange()

		self.max_y = height
		self.max_x = width

		self._recalc_own_size()
		
		return True
		
class Menu(GeometryAware):
	def __init__(self, scr, hless, options, multiple_selection, title):
		if Log.enabled: Log.menu.info('Asked to create menu with title "%s"' % title)
		self.scr = scr
		self.hless = hless
		self.options = options
		self.multiple_selection = multiple_selection
		self.title = ' ' + title + ' '
		
		self.colors = Colors()
		
		self.max_x = 0
		self.max_y = 0
		
		self.cursor = 0
		self.top = 0
		
		self.resized = False
		
		self._recalc_geometry()
		
		if self.multiple_selection:
			self.result = []
		else:
			self.result = None
		self.done = False
		
	def _recalc_own_size(self):
		self.x = 2
		self.max_height = self.max_y - 6
		self.max_width = self.max_x - 4
		
		lengths = [len(x) for x in self.options]
		max_length = max(lengths)
		
		self.height_overflow = False
		
		if len(self.options) > self.max_height - 2:
			self.height = self.max_height
			self.text_height = self.max_height - 2
			self.height_overflow = True
		else:
			self.height = len(self.options) + 2
			self.text_height = len(self.options)

		self.y = self.max_y - self.height - 4
			
		if len(self.title) > self.max_width - 8:
			raise Exception('title is waay to long for terminal of this size')
			
		if self.multiple_selection:
			max_length += 3
			
		max_length = max([max_length, len(self.title) + 8])		
		if max_length > self.max_width - 4:
			self.width = self.max_width
		else:
			self.width = max_length + 4
		self.text_width = self.width - 2
		
		if self.resized:
			if self.height_overflow:
				while self.cursor + 1 >= self.top + self.text_height:
					self.top += 1
			
		self.resized = True

		if Log.enabled: 
			Log.menu.info('After recalculating menu size:')
			Log.menu.info('    x %d, y %d, max_x %d, max_y %d, width %d, height %d, text_height %d' % \
						  (self.x, self.y, self.max_x, self.max_y, self.width, self.height, self.text_height))
			Log.menu.info('    max_width %d, max_height %d' % (self.max_width, self.max_height))
			
	def __process_input(self, c):
		if Log.enabled: Log.menu.info('Menu asked to process %s (%d)' % (KeyName(c), c))

		if c in (curses.ascii.LF, curses.KEY_ENTER):
			if not self.multiple_selection:
				self.result = self.cursor
			self.done = True
		elif c == ord(' '):
			if self.multiple_selection:
				if self.cursor in self.result:
					self.result.remove(self.cursor)
				else:
					self.result.append(self.cursor)
		elif c == ord('q') or c == ord('Q') or c == 27:
			self.done = True
		elif c == curses.KEY_DOWN:
			if self.cursor < len(self.options) - 1:
				self.cursor += 1
			if self.height_overflow:
				if self.cursor + 1 >= self.top + self.text_height:
					if self.top + self.text_height < len(self.options):
						self.top += 1
			else:
				if self.cursor >= self.top + self.text_height:
					if self.top + self.text_height < len(self.options):
						self.top += 1
		elif c == curses.KEY_UP:
			if self.cursor > 0:
				self.cursor -= 1
			if self.top == 0:
				return
			if self.height_overflow:
				if self.cursor == self.top:
					self.top -= 1
			else:
				if self.cursor == self.top - 1:
					self.top -= 1
		
	def Draw(self):
		window = None
		
		while not self.done:
			if self._recalc_geometry():
				window = None
			
			if window == None:
				window = curses.newwin(self.height, self.width, self.y, self.x)
				window.border(curses.ACS_VLINE + self.colors.border.color, curses.ACS_VLINE + self.colors.border.color, \
					curses.ACS_HLINE + self.colors.border.color, curses.ACS_HLINE + self.colors.border.color, \
					curses.ACS_ULCORNER + self.colors.border.color, curses.ACS_URCORNER + self.colors.border.color, \
					curses.ACS_LLCORNER + self.colors.border.color, curses.ACS_LRCORNER + self.colors.border.color)
				window.addstr(0, int((self.width - len(self.title)) / 2), self.title, self.colors.title.color)

				window.noutrefresh()
			curses.doupdate()
			
			drawn = 0
			while drawn < self.text_height:
				if (drawn == 0 and self.top != 0) or (drawn == self.text_height - 1 and self.top + drawn != len(self.options) - 1):
					string = '...'
				else:
					string = self.options[self.top + drawn]
					
				prefix = ''
				if self.multiple_selection:
					if drawn + self.top in self.result and string != '...':
						prefix = '[x]'
					elif string == '...':
						prefix = '   '
					else:
						prefix = '[ ]'
					
				if len(string) > self.text_width:
					string = string[:self.text_width - 3]
					string += '...'
					
				if self.top + drawn == self.cursor:
					color = self.colors.selected_option.color
				else:
					color = self.colors.unselected_option.color
					
				self.scr.addstr(self.y + drawn + 1, self.x + 1, prefix + string.center(self.text_width - len(prefix)), color)
				
				drawn += 1

			c = self.scr.getch()
			self.__process_input(c)
				
			curses.doupdate()
			
		return self.result
		
class ProgressBar(GeometryAware):
	def __init__(self, scr, hless):
		"""height and width here are height and width of the screen and not height and width of the
		progress bar."""
		self.scr = scr
		self.progress = 0.0
		self.max_x = 0
		self.max_y = 0
		self.hless = hless

		self._recalc_geometry()
		
		self.colors = Colors()
		self.brush = Brush(self.scr)
		
	def _recalc_own_size(self):
		self.height, self.width = self.scr.getmaxyx()
		self.y = self.height / 2 - 3
		self.x = int(self.width * 0.1)
		self.progress_width = int(self.width * 0.8)
		
	def SetProgress(self, progress):
		if Log.enabled: Log.main.debug('Asked to set progress to %.2f%%', self.progress)
		self.progress = progress
		
	def Draw(self):
		if Log.enabled: Log.main.debug('Asked to draw progress bar with progress %.2f%%', self.progress)
		
		self._recalc_geometry()
		
		# Drawing the border...
		window = curses.newwin(3, self.progress_width, self.y, self.x)
		window.border(curses.ACS_VLINE + self.colors.border.color, curses.ACS_VLINE + self.colors.border.color, \
			curses.ACS_HLINE + self.colors.border.color, curses.ACS_HLINE + self.colors.border.color, \
			curses.ACS_ULCORNER + self.colors.border.color, curses.ACS_URCORNER + self.colors.border.color, \
			curses.ACS_LLCORNER + self.colors.border.color, curses.ACS_LRCORNER + self.colors.border.color)

		window.noutrefresh()
		curses.doupdate()

		# This is the prompt...
		txt = ('%.2f%%' % self.progress).center(self.progress_width - 2)
		if self.progress == 0:
			l = 0
		else:
			l = int((self.progress_width - 2) * (self.progress / 100))
		self.brush.DrawLine(self.y + 1, self.x + 1, [txt], [LineColor(0, l, self.colors.cursor), \
															LineColor(l, len(txt) - l, self.colors.text)])
			
		self.scr.noutrefresh()
		curses.doupdate()
		
class MsgBox:
	def __init__(self, scr, height, width, text):
		self.scr = scr

		self.height = height
		self.text = text
		
		self.width = max(int(width * 0.4), len(text)) + 2
		if self.width > width:
			raise ValueError('Message text is too long')
			
		self.x = (width - self.width) / 2
		self.y = self.height / 2 - 1
		
		self.colors = Colors()
	
	def Draw(self):
		# Drawing the border...
		window = curses.newwin(3, self.width, self.y, self.x)
		window.border(curses.ACS_VLINE + self.colors.border.color, curses.ACS_VLINE + self.colors.border.color, \
			curses.ACS_HLINE + self.colors.border.color, curses.ACS_HLINE + self.colors.border.color, \
			curses.ACS_ULCORNER + self.colors.border.color, curses.ACS_URCORNER + self.colors.border.color, \
			curses.ACS_LLCORNER + self.colors.border.color, curses.ACS_LRCORNER + self.colors.border.color)

		window.noutrefresh()
		curses.doupdate()

		# This is the prompt...
		text = self.text.center(self.width - 2)
		self.scr.addstr(self.y + 1, self.x + 1, text, self.colors.message.color)

		self.scr.noutrefresh()
		curses.doupdate()		

class SearchPattern:
	def __init__(self, pattern, direction):
		self.pattern = pattern
		self.direction = direction
		self.regex = re.compile(self.pattern)
		self.matches = []
		
	def RegisterSearchMatch(self, line_index):
		indx = bisect.bisect_left(self.matches, line_index)
		if indx < len(self.matches):
			if self.matches[indx] != line_index:
				self.matches.insert(indx, line_index)
		else:
			self.matches.insert(indx, line_index)
			
	def __str__(self):
		return '[' + self.pattern + ']'

class MatchPattern:
	def __init__(self, pattern):
		self.pattern = pattern
		self.regex = re.compile(self.pattern)
		
class Color:
	def __init__(self, color, name):
		self.name = name
		self.color = color

class Colors(object):
	__metaclass__ = Singleton

	def __init__(self):
		curses.use_default_colors()
		curses.curs_set(0)

		curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
		curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
		curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_YELLOW)
		curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_CYAN)
		curses.init_pair(5, curses.COLOR_BLACK, curses.COLOR_MAGENTA)
		curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_GREEN)
		curses.init_pair(7, curses.COLOR_BLACK, curses.COLOR_WHITE)
		curses.init_pair(8, curses.COLOR_WHITE, curses.COLOR_RED)
		curses.init_pair(9, curses.COLOR_YELLOW, curses.COLOR_BLUE)
		curses.init_pair(10, curses.COLOR_WHITE, curses.COLOR_GREEN)

		self.white_on_black = curses.color_pair(0)
		self.white_on_blue = curses.color_pair(1)
		self.black_on_red = curses.color_pair(2)
		self.black_on_yellow = curses.color_pair(3)
		self.black_on_cyan = curses.color_pair(4)
		self.black_on_magenta = curses.color_pair(5)
		self.black_on_green = curses.color_pair(6)
		self.black_on_white = curses.color_pair(7)
		self.white_on_red = curses.color_pair(8)
		self.yellow_on_blue = curses.color_pair(9)
		self.white_on_green = curses.color_pair(10)

		self.status = Color(self.black_on_white, 'status color')
		self.search = Color(self.white_on_black | curses.A_REVERSE, 'search color')
		self.cursor = Color(self.black_on_yellow, 'cursor color')
		self.mark = Color(self.white_on_blue, 'mark color')
		self.text = Color(self.white_on_black, 'text color')
		self.text_bold = Color(self.white_on_black | curses.A_BOLD, 'bold text color')
		self.message = Color(self.white_on_red, 'message color')
		self.border = Color(self.yellow_on_blue, 'border color')
		self.title = Color(self.yellow_on_blue | curses.A_BOLD, 'title color')
		
		self.unselected_option = Color(self.yellow_on_blue, 'unselected cursor color')
		self.selected_option = Color(self.black_on_yellow, 'selected cursor color')

		self.searches = []
		self.searches.append(Color(self.white_on_black | curses.A_REVERSE, 'current search'))
		self.searches.append(Color(self.white_on_red | curses.A_REVERSE, 'red search slot'))
		self.searches.append(Color(self.white_on_green | curses.A_REVERSE, 'green search slot'))
		self.searches.append(Color(self.white_on_blue | curses.A_REVERSE, 'blue search slot'))

class Buffer:
	FILE_TYPE_UNKNOWN = 0
	FILE_TYPE_STDIN = 1
	FILE_TYPE_PLAIN = 2
	FILE_TYPE_COMPRESSED = 3
	FILE_TYPE_COMPRESSED_STDIN = 4
	
	def __init__(self, readahead, progress):
		self.file = Config.file
		self.lines = []
		self.eof = False
		self.readahead = readahead
		
		self.match_patterns = []
		self.hide_patterns = []
		self.match_rxs = []
		self.hide_rxs = []
		
		# Translation table translates line indexes from what is seen on the screen to 
		# lines in the file. Back translation table translates from lines in the file
		# to lines on screen.
		self.translation_table = []
		self.back_translation_table = []
		
		self.prev_translation_table = []
		self.prev_back_translation_table = []

		self.offsets_table = []
		
		self.known_type = False
		self.compressed = False
		self.real_file = Config.file
		self.decomp = None
		
		self.file_type = Buffer.FILE_TYPE_UNKNOWN

		self.buffer = cStringIO.StringIO()

		self.progress = progress

		self.__identify_file_type()
		
	def __len__(self):
		return len(self.translation_table)
		
	def __is_matching(self, line):
		# This is a small workaround to make things snappier.
		if len(self.match_rxs) == 0 and len(self.hide_rxs) == 0:
			return True

		if len(self.match_rxs) == 0:
			matching = True
		else:
			matching = False
			
		matches = 0
		for pattern in self.match_rxs:
			if pattern.regex.search(line):
				matches += 1
				
		if matches == len(self.match_rxs):			
			matching = True
			
		if matching:
			for pattern in self.hide_rxs:
				if pattern.regex.search(line):
					matching = False
					
		return matching
		
	def __rebuild_translation_table(self):
		self.prev_translation_table = self.translation_table
		self.prev_back_translation_table = self.back_translation_table
		
		self.translation_table = []
		self.back_translation_table = range(len(self.lines))
		if Log.enabled: Log.buffer.info('Rebuilding translation table for %d lines', len(self.lines))
		for line_index, line in enumerate(self.lines):
			if self.__is_matching(line):
				if Log.enabled: Log.buffer.debug('Line %d stays at %d', line_index, len(self.translation_table))
				self.translation_table.append(line_index)
				self.back_translation_table[line_index] = len(self.translation_table) - 1
			else:
				if Log.enabled: Log.buffer.debug('Line %d is gone', line_index)
				self.back_translation_table[line_index] = -1
			progress = (float(line_index) / len(self.lines)) * 100
			self.progress.SetProgress(progress)

	def __fill_the_buffer(self):
		buf = self.file.read(64 * 1024)
		if Log.enabled: Log.buffer.info('Read %d bytes from the file' % len(buf))
		pos = self.buffer.tell()
		self.buffer.write(buf)
		self.buffer.seek(pos, 0)
		return len(buf)
				
	def __simple_read_line(self):
		line = self.buffer.readline()
		if line == '':
			self.__fill_the_buffer()
			line = self.buffer.readline()

		while not line.endswith('\n'):
			size = self.__fill_the_buffer()
			if size == 0:
				break
			line += self.buffer.readline()

		if line != '':
			if self.__is_matching(line):
				self.translation_table.append(len(self.lines))
				self.back_translation_table.append(len(self.translation_table) - 1)
			else:
				self.back_translation_table.append(-1)
			if len(self.lines) == 0:
				self.offsets_table.append(0)
			else:
				self.offsets_table.append(self.offsets_table[-1] + len(self.lines[-1]))
			self.lines.append(line)
			if Log.enabled: Log.buffer.debug('Read a line. Total lines in buffer %d', len(self.lines))
		else:
			if Log.enabled: Log.buffer.info('Reached end of file')
			self.eof = True
			self.buffer.close()
				
	def __identify_file_type(self):
		"""Passing the file data through gzip decompression stream and seeing if it works 
		to determine if the file is comressed"""
		if Log.enabled: Log.buffer.info('Trying to figure out file type')
		self.decomp = gzip.GzipFile('', fileobj = Config.file)
		try:
			# If file is compressed, this will cause an exception.
			self.file = self.decomp
			self.__simple_read_line()
			if Config.filename == '<stdin>':
				self.file_type = Buffer.FILE_TYPE_COMPRESSED_STDIN
				self.file_size = 2 ** 32
			else:
				self.file_type = Buffer.FILE_TYPE_COMPRESSED
				s = subprocess.Popen(['gzip', '-l', Config.filename], stdout = subprocess.PIPE)
				ss = s.stdout.read()
				ss = ss.splitlines()[1].split()[1] # this will throw exception if the file is not gzipped..
				self.file_size = int(ss)
		except Exception, ex:
			if Log.enabled: Log.buffer.info('File type seems to be regular file (%s)', traceback.format_exc())
			self.file = self.real_file
			if Config.filename == '<stdin>':
				self.file_type = Buffer.FILE_TYPE_STDIN
				self.file_size = 2 ** 32
			else:
				self.file_type = Buffer.FILE_TYPE_PLAIN
				self.file_size = os.path.getsize(Config.filename)
		else:
			if Log.enabled: Log.buffer.info('File type seems to be gzip')
			
		self.known_type = True
		
	def __read_line(self):
		try:
			self.__simple_read_line()
		except Exception, ex:
			if Log.enabled: Log.buffer.info('Received exception: ' + FormatException(ex))

	def DepthInFile(self):
		"""This routine tells in percent how deep in the file we are."""
		if self.file_type == Buffer.FILE_TYPE_STDIN or self.file_type == Buffer.FILE_TYPE_COMPRESSED_STDIN:
			return 100.0
		elif self.file_type == Buffer.FILE_TYPE_UNKNOWN:
			return 0.0
		else:
			size = self.file_size
			current = self.file.tell()
			res = (float(current) / float(size)) * 100
			return res
	
	def LineOffset(self, line_index):
		"""This routine returns relative offset of the specified line in input file, in percent"""
		if self.file_type == Buffer.FILE_TYPE_STDIN or self.file_type == Buffer.FILE_TYPE_COMPRESSED_STDIN:
			return 100.0
		elif self.file_type == Buffer.FILE_TYPE_UNKNOWN:
			return 0.0

		raw = self.LineToRaw(line_index)
		off = self.offsets_table[raw]

		size = self.file_size
		res = (float(off) / float(size)) * 100
		return res
			
	def ReadEntireFile(self):
		"""This routine reads entire file"""
		while not self.eof:
			self.__simple_read_line()
			self.progress.SetProgress(self.DepthInFile())
			
	def ReadFirstN(self, n):
		"""This routine reads until either end of file or first n lines"""
		while not self.eof and len(self.lines) < n:
			self.__simple_read_line()

	def LineToRaw(self, line_index):
		if line_index >= len(self.translation_table):
			return -1
		else:
			return self.translation_table[line_index]
			
	def RawToLine(self, line_index):
		if line_index >= len(self.back_translation_table):
			return -1
		else:
			return self.back_translation_table[line_index]

	def PrevLineToCurrent(self, line_index):
		"""This routine assumes that translation table has changed (either because of changes in match patterns
		or because of change in hide patterns). It translates from line index in old translation table to 
		new translation table."""
		if line_index  >= len(self.prev_translation_table):
			return -1
		old_raw = self.prev_translation_table[line_index]
		res = self.back_translation_table[old_raw]
		
		if Log.enabled: Log.buffer.debug('Line %d is now at %d', line_index, res)
		
		return res
		
	def PostProcessPatternChange(self):
		self.match_rxs = []
		for pat in self.match_patterns:
			self.match_rxs.append(MatchPattern(pat))
		self.hide_rxs = []
		for pat in self.hide_patterns:
			self.hide_rxs.append(MatchPattern(pat))
			
		self.__rebuild_translation_table()

	def AddHidePattern(self, pat):
		self.hide_patterns.append(MatchPattern(pat))
		self.__rebuild_translation_table()
		
	def GetLine(self, indx):
		while indx + self.readahead >= len(self.translation_table) and not self.eof:
			self.__read_line()
			
		if indx < len(self.translation_table):
			return self.lines[self.translation_table[indx]]
		else:
			return None
	
	def ResetEof(self):
		self.eof = False
		
	def Eof(self):
		return self.eof
		
	def GetRealLength(self):
		return len(self.lines)
		
	def HasMatchPattern(self):
		return len(self.match_rxs) > 0 or len(self.hide_rxs) > 0

class LineColor:
	def __init__(self, start, length, color):
		self.start = start
		self.length = length
		self.color = color
		
	def __str__(self):
		return "%d-%d (%d) %s" % (self.start, self.start + self.length, self.length, self.color.name)
		
	def __repr__(self):
		return "%d-%d (%d) %s" % (self.start, self.start + self.length, self.length, self.color.name)

class Brush:
	def __init__(self, scr):
		self.scr = scr
		self.colors = Colors()

	def __put_line(self, y, x, line, color):
		if Log.enabled: Log.brush.debug('        Asked to draw line %d characters long at %d-%d with color %s', len(line), y, x, \
			color.name)
		if len(line) > 0:
			try:
				self.scr.addstr(y, x, line, color.color)
			except Exception, ex:
				if Log.enabled: Log.brush.warn('Received exception %s when printed a line:' % str(ex))
				if Log.enabled: Log.brush.warn(line)
					
			self.scr.noutrefresh()
			
	def DrawSingleLine(self, offset_in_line, y, x, line, colors):
		if Log.enabled: Log.brush.debug('    Asked to draw single line %d characters long at %d-%d with colors %s', len(line), y, \
			offset_in_line, colors)

		if len(colors) == 0:
			# This is the simplest case. We're asked to draw the line without any color - i.e. with text color.
			self.__put_line(y, 0, line, self.colors.text)
			return
			
		drawn = False
		for color in colors:
			if ((color.start >= offset_in_line) and (color.start < offset_in_line + len(line))) or \
				((offset_in_line >= color.start) and (offset_in_line < color.start + color.length)):
				color_start = color.start - offset_in_line
				if color_start < 0:
					color_start = 0
				color_end = min(color.start + color.length - offset_in_line, len(line))
					
				# We've found LineColor that gives color specification for the line we're asked
				# to draw. 
				# We can split our line into three: first part is the one before color, second part
				# is the colored one and third part is after color.
				first = line[:color_start]
				second = line[color_start:color_end]
				third = line[color_end:]

				if not drawn:
					self.__put_line(y, x, first, self.colors.text)
					self.__put_line(y, x + len(first) + len(second), third, self.colors.text)

				self.__put_line(y, x + len(first), second, color.color)
				
				drawn = True

		if not drawn:
			self.__put_line(y, 0, line, self.colors.text)

	def DrawLine(self, y, x, lines, colors):
		if Log.enabled: Log.brush.debug('Asked to draw line at %d/%d, with %d sub-lines and colors %s', y, x, len(lines), str(colors))
		
		self.height, self.width = self.scr.getmaxyx()		
		
		line_index = 0
		offset = 0
		for line in lines:
			if y + line_index < self.height:
				self.DrawSingleLine(offset, y + line_index, x, line, colors)
				line_index += 1
				offset += len(line)
				
class EditBox(GeometryAware):
	def __init__(self, hless, scr, prompt, history, value, border = True):
		GeometryAware.__init__(self, scr, hless)
		self.prompt = prompt
		self.colors = Colors()
		self.proceed = True

		self.special_enter = False

		self.pos = 0

		self.esc = False
		self.numpad = False
		
		self.history = copy.copy(history)
		self.buffer_ptr = len(self.history)
		self.history.append(value)
		self.cursor = len(value)
		
		self.max_x = 0
		self.max_y = 0
		
		self._recalc_geometry()
		
		if Log.enabled: Log.editbox.info('Asked to draw editbox at %d-%d, %d characters wide, %d strings in history, with prompt %s', \
			self.y, self.x, self.width, len(self.history), self.prompt)
	
	def _recalc_own_size(self):
		self.width = self.max_x
		self.height = 2
		self.x = 0
		self.y = self.max_y - 2
		self.text_width = self.width - len(self.prompt)
		
	def __calc_window(self):
		win = self.history[self.buffer_ptr][self.pos:]
		win = win[:self.text_width]
		if len(win) < self.text_width:
			spacer = ' ' * (self.text_width - len(win) - 1)
			win += spacer
		return win

	def __place_cursor(self):
		self.scr.move(self.y + 1, self.cursor + self.x + len(self.prompt) - self.pos)

	def __handle_user_input(self, c):
		if Log.enabled: Log.editbox.debug('EditBox received key press %s at %d/%d', KeyName(c), self.pos, self.cursor)

		if c in (curses.ascii.LF, curses.KEY_ENTER): # Enter key
			self.proceed = False
			if self.esc:
				self.special_enter = True
			
		word_separator = '[ \t\*\?_\.\[\]\~\=\&\%\^\(\)\{\}\<\>]+'
			
		if c == curses.ascii.ESC:
			self.esc = True
		# ALT+b
		elif c == ord('b') and self.esc == True:
			lst = []
			for m in re.finditer(word_separator, self.history[self.buffer_ptr][:self.cursor]):
				lst.append(m.start())
			if len(lst) > 0:
				self.cursor = lst[-1]
			else:
				self.cursor = 0
		# ALT+f
		elif c == ord('f') and self.esc == True:
			lst = []
			for m in re.finditer(word_separator, self.history[self.buffer_ptr][self.cursor:]):
				lst.append(m.end() + self.cursor)
			if len(lst) > 0:
				self.cursor = lst[0]
			else:
				self.cursor = len(self.history[self.buffer_ptr])
		# ALT+Backspace
		elif c in (curses.ascii.BS, curses.KEY_BACKSPACE) and self.esc == True:
			lst = []
			for m in re.finditer(word_separator, self.history[self.buffer_ptr][:self.cursor]):
				lst.append(m.start())
			if len(lst) > 0:
				self.history[self.buffer_ptr] = self.history[self.buffer_ptr][:lst[-1]] + \
					self.history[self.buffer_ptr][self.cursor:]
				self.cursor = lst[-1]
			else:
				self.history[self.buffer_ptr] = self.history[self.buffer_ptr][self.cursor:]
				self.cursor = 0
		# Letter or space character
		elif curses.ascii.isgraph(c) or c == ord(' '):
			self.history[self.buffer_ptr] = self.history[self.buffer_ptr][:self.cursor] + chr(c) + \
				self.history[self.buffer_ptr][self.cursor:]
			self.cursor += 1
			if self.cursor > self.pos + self.text_width:
				self.pos += 1
		# Backspace
		elif c in (curses.ascii.BS, curses.KEY_BACKSPACE):
			if len(self.history[self.buffer_ptr]) > 0:
				self.history[self.buffer_ptr] = self.history[self.buffer_ptr][:self.cursor - 1] + \
					self.history[self.buffer_ptr][self.cursor:]
				self.cursor -= 1
		# Delete
		elif c == curses.KEY_DC:
			if self.cursor < len(self.history[self.buffer_ptr]):
				self.history[self.buffer_ptr] = self.history[self.buffer_ptr][:self.cursor] + \
					self.history[self.buffer_ptr][self.cursor + 1:]
		# Left
		elif c == curses.KEY_LEFT:
			if self.cursor > 0:
				self.cursor -= 1
		# Right
		elif c == curses.KEY_RIGHT:
			if self.cursor < len(self.history[self.buffer_ptr]):
				self.cursor += 1
		# End
		elif c == curses.KEY_END:
			self.cursor = len(self.history[self.buffer_ptr])
		# Home
		elif c == curses.KEY_HOME:
			self.cursor = 0
		# Up
		elif c == curses.KEY_UP:
			if len(self.history) == 0:
				return
				
			self.buffer_ptr -= 1
			if self.buffer_ptr < 0:
				self.buffer_ptr = 0
				return
			self.cursor = len(self.history[self.buffer_ptr])
			if Log.enabled: Log.editbox.info('Setting history ptr to %d', self.buffer_ptr)
		# Down
		elif c == curses.KEY_DOWN:
			if len(self.history) == 0:
				return
			
			self.buffer_ptr += 1
			if self.buffer_ptr >= len(self.history):
				self.buffer_ptr -= 1
				return
			self.cursor = len(self.history[self.buffer_ptr])
			if Log.enabled: Log.editbox.info('Setting history ptr to %d', self.buffer_ptr)
			
		if self.cursor < self.pos:
			self.pos = self.cursor
			
		if c != curses.ascii.ESC:
			self.esc = False

		if Log.enabled: Log.editbox.debug('After processing %s cursor and pos are at %d and %d', curses.keyname(c), self.pos, self.cursor)
			
	def Run(self):
		if Log.enabled: Log.editbox.info('Running the editbox')

		curses.curs_set(1)
		curses.setsyx(self.y + 2, self.x)

		while self.proceed:
			self._recalc_geometry()
			
			# This is the border...			
			self.scr.hline(self.y, self.x, curses.ACS_HLINE | self.colors.border.color, self.width)
			# This is the prompt...
			self.scr.addstr(self.y + 1, self.x, self.prompt, self.colors.border.color)

			win = self.__calc_window()
			self.scr.addstr(self.y + 1, self.x + len(self.prompt), win, self.colors.text.color)
			self.__place_cursor()

			self.scr.noutrefresh()
			curses.doupdate()

			# Now waiting for some input...
			try:
				c = self.scr.getch()
				self.__handle_user_input(c)
			except KeyboardInterrupt:
				self.history[self.buffer_ptr] = ''
				self.proceed = False

		curses.curs_set(0)

		return self.history[self.buffer_ptr], self.special_enter
		
class StatusBar:
	def __init__(self, scr, hless):
		self.scr = scr
		self.hless = hless
		self.buffer = self.hless.buffer
		self.brush = Brush(self.hless.scr)
		self.colors = Colors()
		self.editbox = None
		self.progress_indicator = ''
		
	def __add_search_results(self, searches):
		res = ''

		colors = []
		for search_index, search in enumerate(searches):
			if search == None:
				continue
			
			if search_index != 0:
				if len(res) != 0:
					res += ','

			if len(search.matches) == 0:
				new = '----/----'
				colors.append(LineColor(len(res), len(new), self.colors.searches[search_index]))
				res += new
				continue
	
			# Looking for previous match...	
			indx = len(search.matches) - 1
			while indx >= 0:
				match = self.hless.buffer.RawToLine(search.matches[indx])
				if match >= 0 and match < self.hless.cursor:
					break
				indx -= 1
	
			if indx < 0:
				new = '----'
			else:
				new = '-%d' % (self.hless.cursor - match)
	
			new += '/'
	
			# Looking for next match...
			indx = 0
			while indx < len(search.matches):
				match = self.hless.buffer.RawToLine(search.matches[indx])
				if match > self.hless.cursor:
					break
				indx += 1 
	
			if indx >= len(search.matches):
				new += '----'
			else:
				new += '+%d' % (match - self.hless.cursor)

			colors.append(LineColor(len(res), len(new), self.colors.searches[search_index]))
			res += new

		colors = [LineColor(0, len(res), self.colors.status)] + colors
		return res, colors

	def __add_marks(self):
		res = ''
		if len(self.hless.marks) == 0:
			return res, []

		indx = len(self.hless.marks) - 1
		while indx >= 0:
			if self.hless.marks[indx] < self.hless.cursor:
				break
			indx -= 1

		if indx < 0:
			res += '----'
		else:
			res += '-%d' % (self.hless.cursor - self.hless.marks[indx])

		res += '/'

		indx = 0
		while indx < len(self.hless.marks):
			if self.hless.marks[indx] > self.hless.cursor:
				break
			indx += 1 

		if indx >= len(self.hless.marks):
			res += '----'
		else:
			res += '+%d' % (self.hless.marks[indx] - self.hless.cursor)

		return res, [LineColor(0, len(res), self.colors.mark)]

	def __add_search_direction(self, searches):
		res = ''
		for search in searches:
			if search != None:
				if search.direction == HLess.SEARCH_DIRECTION_DOWN:
					res += 'D'
				else:
					res += 'U'
			else:
				res += '-'
		return res
	
	def __add_line_numbers(self):
		if self.buffer.Eof():
			if len(self.buffer) > 0:
				percent = (float(self.hless.cursor + 1) / float(len(self.buffer))) * 100
				if percent > 100: # This actually can happen when filtering out some lines.
					percent = 100.0
			else:
				percent = 0.0
			percent = ' %.2f%%' % percent
			if self.buffer.HasMatchPattern():
				lines = '%d(%d)' % (len(self.buffer), self.buffer.GetRealLength())
			else:
				lines = '%d' % (len(self.buffer))
		else:
			percent = ''
			lines = '----'

		if self.buffer.HasMatchPattern():
			res = '%d(%d)/%s%s' % (self.hless.cursor + 1, \
				self.buffer.LineToRaw(self.hless.cursor) + 1, lines, percent)
		else:
			res = '%d/%s%s' % (self.hless.cursor + 1, lines, percent)
			
		return res

	def __draw_first_status_bar(self):
		status1 = ' '.ljust(self.hless.width)
		self.brush.DrawLine(self.hless.text_height, 0, [status1], [LineColor(0, len(status1), self.colors.status)])

		pos = 0
		status1 = ' '
		status1 += self.__add_line_numbers()
		self.brush.DrawLine(self.hless.text_height, pos, [status1], [LineColor(0, len(status1), self.colors.status)])
		pos += len(status1)

		res = self.__add_search_direction(self.hless.searches)
		if res != '':
			status1 = '  |  ' + res
			self.brush.DrawLine(self.hless.text_height, pos, [status1], [LineColor(0, len(status1), self.colors.status)])
			pos += len(status1)
		
		res, colors = self.__add_search_results(self.hless.searches)
		if res != '':
			status1 = '  |  '
			self.brush.DrawLine(self.hless.text_height, pos, [status1], [LineColor(0, len(status1), self.colors.status)])
			pos += len(status1)
			self.brush.DrawLine(self.hless.text_height, pos, [res], colors)
			pos += len(res)
		
		res, colors = self.__add_marks()
		if res != '':
			status1 = '  |  '
			self.brush.DrawLine(self.hless.text_height, pos, [status1], [LineColor(0, len(status1), self.colors.status)])
			pos += len(status1)
			self.brush.DrawLine(self.hless.text_height, pos, [res], colors)
			pos += len(res)
		
	def __draw_second_status_bar(self):
		status2 = ' ' + Config.filename

		if self.hless.tail_mode:
			status2 += '  |  Tail mode'
			
		status2 = status2.ljust(self.hless.width - 1)
		self.brush.DrawLine(self.hless.text_height + 1, 0, [status2], [LineColor(0, len(status2), self.colors.status)])

	def Draw(self):
		self.__draw_first_status_bar()
		if self.editbox:
			self.editbox.PlaceCursor()
		else:
			self.__draw_second_status_bar()

		curses.doupdate()

class HLess:
	SEARCH_DIRECTION_NONE = 0
	SEARCH_DIRECTION_DOWN = 1
	SEARCH_DIRECTION_UP = 2

	def __init__(self, scr, file):
		self.done = False

		self.colors = Colors()
		
		self.scr = scr

		self.height, self.width = self.scr.getmaxyx()
		self.text_height = self.height - Config.STATUS_BAR_HEIGHT
		if Log.enabled: Log.main.info('Initializing terminal. Height - %d, width - %d, text height - %d', self.height, self.width, self.text_height)
		
		self.brush = Brush(self.scr)

		self.current = 0 # this is first buffer file that we see on the screen.
		self.line_in_current = 0 # this is the line inside of current.

		self.bottom_line = 0 # this is the index of the file line of the bottom most line on screen.
		self.line_in_bottom = 0 # this is the string in the bottom most line.

		self.cursor = 0 # location of the cursor relative to entire file.
		self.cursor_at_top = False
		self.cursor_at_bottom = False

		self.real_marks = []
		self.marks = []
		
		self.searches = [None for x in range(4)]

		self.progress_thread = None
		self.has_progress = False

		self.show_line_numbers = False
		self.lines_on_screen = 0
		
		self.tail_mode = False
		
		self.fix_cursor_position = False
		self.fix_current_position = False
		self.mediate_cursor_position = False
		
		self.progress_bar = ProgressBar(self.scr, self)
		self.buffer = Buffer(self.height, self.progress_bar)
		self.status_bar = StatusBar(self.scr, self)
		
		self.history_list = []
		
	def ClearInputBuffer(self):
		self.scr.timeout(0)
		while self.scr.getch() >= 0: 
			pass

	def ReadInput(self):
		self.scr.timeout(-1)
		c = self.scr.getch()
		return c
		
	def GetLineNumberWidth(self):
		return len('%d' % (self.current + self.lines_on_screen + 1)) + 1

	def GetLineColor(self, lines, line_index):
		length = 0
		for line in lines:
			length += len(line)

		color = []
		if self.show_line_numbers:
			w = self.GetLineNumberWidth()
			offset = 0
			color.append(LineColor(0, w, self.colors.text_bold))
			for line in lines:
				if line_index == self.cursor:
					color.append(LineColor(w + offset, len(line) - w, self.colors.cursor))
				elif line_index in self.marks:
					color.append(LineColor(w + offset, len(line) - w, self.colors.mark))
				offset += len(line)
		else:
			if line_index == self.cursor:
				color.append(LineColor(0, length, self.colors.cursor))
			elif line_index in self.marks:
				color.append(LineColor(0, length, self.colors.mark))
			
		return color

	def SplitLine(self, line_index, line):
		start = 0
		res = []
		
		width = self.width
		
		num = ''
		if self.show_line_numbers:
			num = str(line_index + 1).ljust(self.GetLineNumberWidth())
			width -= len(num)

		line = line.rstrip()
		if line != '':
			first_line = True
			while len(line) > 0:
				length = min(width, len(line))
				l = line[:length]
	
				if first_line:
					l = num + l
					first_line = False
				else:
					l = (' ' * len(num)) + l
					
				res.append(l)
				line = line[length:]
		else:
			res = ['']
			
		return res
		
	def MatchSearchPattern(self, line_index, line):
		res = []
		
		# This is a debug code. Shouldn't be in release version.
		if type(line) != types.StringType:
			raise TypeError(type(line))
			
		for i in range(4):
			if self.searches[i] != None:
				if Log.enabled: Log.search.debug('Checking if line "%s" matches %s', line, self.searches[i].pattern)
				for m in self.searches[i].regex.finditer(line):
					if Log.enabled: Log.search.debug('Found search pattern %s match in line %d: %d %d', self.searches[i].pattern, line_index, m.start(), m.end())
					start = m.start()
					if self.show_line_numbers:
						start += self.GetLineNumberWidth()
					end = m.end() - m.start()
					res.append(LineColor(start, end, self.colors.searches[i]))
					true_line_index = self.buffer.LineToRaw(line_index)
					self.searches[i].RegisterSearchMatch(true_line_index)
			
		return res
		
	def GetLinesOnScreen(self):
		# Checking number of lines on screen starting self.current. Then making sure cursor is on screen...
		height, width = self.scr.getmaxyx()
		if height != self.height or width != self.width:
			self.height = height
			self.width = width
			self.text_height = self.height - Config.STATUS_BAR_HEIGHT
		
		i = 0
		j = self.line_in_current
		line_in_bottom = j
		cnt = 0
		while cnt < self.text_height:
			line = self.buffer.GetLine(self.current + i)
			if line == None:
				break

			lines = self.SplitLine(self.current + i, line)
			line_in_bottom = self.text_height - cnt - 1
			cnt += len(lines) - j
				
			i += 1
			j = 0
			
		return i, line_in_bottom
		
	def NoteGeometryChange(self):
		self.FixCursorPosition()
		self.RedrawScreen()
		
	def FixCurrentAndCursorPositions(self):
		"""Fixes current and cursor positions according to flags set earlier. Depending
		on circumstances, we may need to fix current position, but leave cursor as is or
		fix cursor, leaving current as is."""
		if self.fix_cursor_position:
			self.FixCursorPosition()
			self.fix_cursor_position = False

		if self.fix_current_position:
			self.FixCurrentPosition()
			self.fix_current_position = False

		if self.mediate_cursor_position:
			self.MediateCursorPosition()
			self.mediate_cursor_position = False
			
		if Log.enabled: Log.screen.info('After fixing current/cursor positions: Current %d.%d, cursor at %d', \
			self.current, self.line_in_current, self.cursor)

	def ExpandSpecialSymbols(self, line, matches):
		# Getting rid of tabs
		start = -1
		index = 0
		while True:
			index = line.find('\t', start + 1)
			if index == -1:
				break
			start = index
			if Log.enabled: Log.screen.debug('Found some tabs in the line at %d. Expanding...' % index)
			line = line[:index] + (' ' * Config.tab_width) + line[index + 1:]
			for m in matches:
				if index < m.start:
					m.start += Config.tab_width - 1
				elif index >= m.start and index < m.start + m.length:
					m.length += Config.tab_width - 1
		return line
		
	def RedrawScreen(self):
		if Log.enabled: Log.screen.info('Redrawing. Current %d.%d, cursor at %d, bottom at %d.%d, cursor at bottom %s, top %s',
			self.current, self.line_in_current, self.cursor, self.bottom_line, self.line_in_bottom, \
			str(self.cursor_at_bottom), str(self.cursor_at_top))
		
		# Updating the height and width of the screen, just in case it has been resized.
		self.height, self.width = self.scr.getmaxyx()
		self.text_height = self.height - Config.STATUS_BAR_HEIGHT

		if Log.enabled: Log.screen.info('Screen size is %d/%d', self.height, self.width)
		
		self.FixCurrentAndCursorPositions()
		
		self.lines_on_screen, line_in_last = self.GetLinesOnScreen()

		self.cursor_at_top = False
		self.cursor_at_bottom = False

		i = 0
		j = self.line_in_current
		cnt = 0
		lines = []
		while cnt < self.text_height:
			line = self.buffer.GetLine(self.current + i)
			if line == None:
				self.bottom_line = self.current + i - 1
				self.line_in_bottom = len(lines) - 1
				break

			matches = self.MatchSearchPattern(self.current + i, line)
			line = self.ExpandSpecialSymbols(line, matches)
			lines = self.SplitLine(self.current + i, line)

			if Log.enabled:  
				Log.screen.debug('Read line %d from file:', self.current + i)
				for one in lines:
					if len(one) > 80:
						Log.screen.debug('    ' + one[:80] + '...')
					else:
						Log.screen.debug('    ' + one)

			lines[-1] = lines[-1].ljust(self.width)
			lines = lines[j:]
			color = self.GetLineColor(lines, self.current + i)
			color += matches

			lines_widths = [len(x) for x in lines]
			if Log.enabled: Log.screen.debug('Drawing line %d, %d characters and %d (%s) lines long at %d with colors %s',
				self.current + i, len(line), len(lines), str(lines_widths), cnt, str(color))

			self.brush.DrawLine(cnt, 0, lines, color)
			self.bottom_line = self.current + i
			if cnt + len(lines) >= self.text_height:
				temp = self.text_height - cnt - 1
				self.line_in_bottom = temp
			cnt += len(lines)

			j = 0
			i += 1
			
		while cnt < self.text_height:
			l = ' ' * self.width
			if Log.enabled: Log.screen.debug('Drawing empty line at %d', cnt)
			self.brush.DrawLine(cnt, 0, [l], [])
			cnt += 1
			
		if self.cursor == self.current:
			self.cursor_at_top = True
		if self.cursor >= self.bottom_line:
			self.cursor_at_bottom = True
			
		self.status_bar.Draw()
	
		curses.doupdate()

		if Log.enabled: Log.screen.info('After redrawing the screen, current - %d.%d, bottom - %d.%d, cursor - %d, cursor at bottom - %s, top - %s', \
			self.current, self.line_in_current, self.bottom_line, self.line_in_bottom, self.cursor, str(self.cursor_at_bottom), \
			str(self.cursor_at_top))
			
	def FixCurrentPosition(self):
		"""In case cursor moves beyond boundaries of the screen, moving 
		current so that cursor will remain visible."""
		
		self.current = self.cursor - self.text_height
		if self.current < 0:
			self.current = 0
			
		lines, line_in_last = self.GetLinesOnScreen()
		while self.cursor >= self.current + lines:
			self.current += 1
			lines, line_in_last = self.GetLinesOnScreen()
		line = self.buffer.GetLine(self.cursor)
		lines = self.SplitLine(self.cursor, line)
		for line in lines[1:]:
			self.current += 1
			
	def MediateCursorPosition(self):
		"""Fixes current value so that cursor will appear in the middle of the screen"""
		
		self.current = self.cursor - self.text_height
		if self.current < 0:
			self.current = 0
			return
			
		lines, line_in_last = self.GetLinesOnScreen()
		while self.cursor > self.current + (lines / 2):
			self.current += 1
			lines, line_in_last = self.GetLinesOnScreen()
			
	def FixCursorPosition(self):
		"""In case cursor moves beyond boundaries of the screen, moving 
		it back so that it will remain visible."""
		
		lines, line_in_last = self.GetLinesOnScreen()
		
		if Log.enabled: Log.keys.debug('In FixCursorPosition(), lines on screen %d, cursor %d, current %d', lines, self.cursor, self.current)
		
		if self.cursor >= self.current + lines:
			self.cursor = self.current + lines - 1
			self.cursor_at_bottom = True
		else:
			self.cursor_at_bottom = False

		if self.cursor < self.current:
			self.cursor = self.current
			self.cursor_at_top = True
		else:
			self.cursor_at_top = False
			
		if Log.enabled: Log.keys.debug('After fixing cursor position, cursor at %d, current at %d', self.cursor, self.current)
		
	def HandleKeyDown(self):
		if Log.enabled: Log.keys.info('Cursor at %d, current - %d.%d, bottom line - %d.%d, buffer eof - %d, buffer length - %d', \
			self.cursor, self.current, self.line_in_current, self.bottom_line, self.line_in_bottom, \
			self.buffer.Eof(), len(self.buffer))

		if not self.cursor_at_bottom:
			self.cursor += 1
			line = self.buffer.GetLine(self.cursor)
			if line == None:
				self.cursor -= 1
			return

		# Taking care of case when we are at the bottom of the file
		if self.buffer.Eof():
			line = self.buffer.GetLine(self.bottom_line)
			lines = self.SplitLine(self.bottom_line, line)
			
			if Log.enabled: Log.keys.debug('Bottom line is %d. Lines in bottom line %d', self.bottom_line, len(lines))
			
			if self.cursor >= len(self.buffer) - 1 and self.line_in_bottom == len(lines) - 1:
				return

		# Calculating if we should move the cursor forward.
		line = self.buffer.GetLine(self.bottom_line)
		lines = self.SplitLine(self.bottom_line, line)

		if self.line_in_bottom == len(lines) - 1:
			self.cursor += 1

		# Now moving the screen one line lower.
		line = self.buffer.GetLine(self.current)
		lines = self.SplitLine(self.current, line)
		if Log.enabled: Log.keys.debug('Current line has %d sub-lines and we are on subline %d', len(lines), self.line_in_current)
		self.line_in_current += 1
		if self.line_in_current >= len(lines):
			self.current += 1
			self.line_in_current = 0

	def HandleKeyUp(self):
		if Log.enabled: Log.keys.info('Cursor at %d, current - %d.%d, bottom line - %d.%d', self.cursor, self.current, \
			self.line_in_current, self.bottom_line, self.line_in_bottom)

		if not self.cursor_at_top:
			self.cursor -= 1
			return

		if self.line_in_current != 0:
			self.line_in_current -= 1
			return 

		if self.current == 0:
			return 

		self.current -= 1
		line = self.buffer.GetLine(self.current)
		lines = self.SplitLine(self.current, line)
		self.line_in_current = len(lines) - 1
		self.cursor -= 1

	def HandlePageup(self):
		if Log.enabled: Log.keys.info('Cursor at %d, current - %d.%d, bottom line - %d.%d, buffer eof - %d, buffer length - %d', \
			self.cursor, self.current, self.line_in_current, self.bottom_line, self.line_in_bottom, \
			self.buffer.Eof(), len(self.buffer))
		
		self.line_in_current = 0
		if self.current - self.lines_on_screen <= 0:
			self.current = 0
			self.cursor = 0
		else:
			self.current -= self.lines_on_screen
			self.cursor -= self.lines_on_screen
		self.fix_cursor_position = True

	def HandlePagedown(self):
		if Log.enabled: Log.keys.info('Cursor at %d, current - %d.%d, bottom line - %d.%d, buffer eof - %d, buffer length - %d', \
			self.cursor, self.current, self.line_in_current, self.bottom_line, self.line_in_bottom, \
			self.buffer.Eof(), len(self.buffer))
		
		if self.current + self.lines_on_screen >= len(self.buffer):
			self.cursor = len(self.buffer) - 1
		else:
			self.line_in_current = 0
			self.current += self.lines_on_screen
			self.cursor += self.lines_on_screen
		self.fix_cursor_position = True
		
	def ToggleMark(self):
		raw = self.buffer.LineToRaw(self.cursor)
		if not raw in self.real_marks:
			self.real_marks.append(raw)
			self.marks.append(self.cursor)
		else:
			self.real_marks.remove(raw)
			self.marks.remove(self.buffer.RawToLine(raw))
		self.real_marks.sort()
		self.marks.sort()
		
	def FindNextSearchMatch(self, search, from_start = False):
		if not self.buffer.Eof(): # not showing progress bar if there's no IO
			self.StartProgress()

		old_current = self.current
		old_cursor = self.cursor
		if from_start:
			self.current = 0
			self.cursor = 0
		match = False
		self.cursor += 1
		line = self.buffer.GetLine(self.cursor)
		while line != None:
			if Log.enabled: Log.search.debug('Looking for the next match of %s in line %d', search, self.cursor)
			if search.regex.search(line):
				if Log.enabled: Log.search.debug('Line %d matches the pattern %s', self.cursor, search)
				lines, line_in_last = self.GetLinesOnScreen()
				if self.current + lines <= self.cursor:
					self.current = self.cursor - (lines / 2)
				self.cursor = self.cursor
				true_line_index = self.buffer.LineToRaw(self.cursor)
				search.RegisterSearchMatch(true_line_index)
				match = True
				break
			self.cursor += 1
			line = self.buffer.GetLine(self.cursor)
			
			progress = self.buffer.LineOffset(self.cursor)
			self.progress_bar.SetProgress(progress)

		if not match:
			self.current = old_current
			self.cursor = old_cursor
			self.MessageBox('No match found')
		else:
			self.mediate_cursor_position = True
			
	def FindPrevSearchMatch(self, search, from_end = False):
		if not self.buffer.Eof(): # not showing progress bar if there's no IO
			self.StartProgress()

		old_current = self.current
		old_cursor = self.cursor

		if from_end:
			if not self.buffer.Eof():
				self.MessageBox('Going to the end of the file')
				self.GotoEOF()
				self.MessageBox('Searching for the pattern')
				self.cursor = len(self.buffer.lines) - 1

		match = False
		self.cursor -= 1
		while self.cursor >= 0:
			if Log.enabled: Log.search.debug('Looking for the previous match of %s in line %d', search, self.cursor)
			line = self.buffer.GetLine(self.cursor)
			if search.regex.search(line):
				if Log.enabled: Log.search.debug('Line %d matches the pattern %s', self.cursor, search)
				lines, line_in_last = self.GetLinesOnScreen()
				if self.cursor < self.current:
					self.current = self.cursor - (lines / 2)
					if self.current < 0:
						self.current = 0
				self.cursor = self.cursor
				true_line_index = self.buffer.LineToRaw(self.cursor)
				search.RegisterSearchMatch(true_line_index)
				match = True
				break
			self.cursor -= 1
			
			progress = self.buffer.LineOffset(self.cursor)
			self.progress_bar.SetProgress(100 - progress)
			
		if not match:
			self.current = old_current
			self.cursor = old_cursor
			self.MessageBox('No match found')
		else:
			self.mediate_cursor_position = True			
			
	def DoSearch(self, c):
		if c == ord('/'):
			search_string = "Search: "
		else:
			search_string = "Search Backward: "
			
		ret, special_enter = self.SpawnEdit(search_string)

		if Log.enabled: Log.search.info('Asked to search for "%s"', ret)

		if ret == '':
			return

		if c == ord('/'):
			direction = HLess.SEARCH_DIRECTION_DOWN
		else:
			direction = HLess.SEARCH_DIRECTION_UP
			
		search = SearchPattern(ret, direction)
		self.searches[0] = search
	
		if not self.tail_mode:
			if not self.buffer.Eof():
				self.StartProgress()
			if self.searches[0].direction == HLess.SEARCH_DIRECTION_DOWN:
				self.FindNextSearchMatch(self.searches[0], from_start = special_enter)
			else:
				self.FindPrevSearchMatch(self.searches[0], from_end = special_enter)
				
	def HandleColon(self):
		ret, special_enter = self.SpawnEdit('Goto line: ')
		
		if Log.enabled: Log.navigate.info('Asked to go to line %s ', ret)
		if ret == '':
			return

		line = -1
		try:
			line = int(ret)
		except ValueError:
			if Log.enabled: Log.navigate.info('Asked to go to something that is not a number')
			line = -1

		if line == -1:
			return
			
		line -= 1

		self.mediate_cursor_position = True

		if len(self.buffer) < line:
			self.StartProgress()

			lines, line_in_last = self.GetLinesOnScreen()
			if line < self.cursor:
				self.cursor = line
			else:
				txt = self.buffer.GetLine(self.cursor)
				while txt != None and self.cursor < line:
					self.cursor += 1
					txt = self.buffer.GetLine(self.cursor)
					progress = self.buffer.LineOffset(self.cursor)
					self.progress_bar.SetProgress(progress)
				if txt == None:
					self.cursor -= 1
			self.current = self.cursor - (int(self.text_height * 0.8))
		else:
			self.cursor = line
			
	def MessageBox(self, txt):
		has_progress = self.has_progress
		if has_progress:
			self.StopProgress()
		self.RedrawScreen()
		msg = MsgBox(self.scr, self.text_height, self.width, txt)
		msg.Draw()
		self.scr.timeout(1000)
		c = self.scr.getch()
		self.scr.timeout(-1)
		self.RedrawScreen()
		if has_progress:
			self.StartProgress()
			
	def StartProgress(self):
		if self.progress_thread == None:
			self.progress_bar.SetProgress(0)
			self.progress_thread = ProgressThread(self.progress_bar)
			self.progress_thread.start()
			self.has_progress = True

	def StopProgress(self):
		if self.progress_thread:
			self.progress_thread.keep_running = False
			self.progress_thread.stop_event.set()
			self.progress_thread.join()
			self.progress_thread = None
			self.status_bar.progress_indicator = ''
			self.has_progress = False

	def GotoEOF(self):
		self.fix_current_position = True
		
		if Log.enabled: Log.navigate.info('Asked to go to end of file')

		if not self.tail_mode:
			self.StartProgress()
		
		if not self.buffer.Eof():
			self.buffer.ReadEntireFile()
			
		self.cursor = len(self.buffer) - 1
		self.fix_current_position = True
			
		if Log.enabled: Log.navigate.info('After going to end of file, current %d.%d, cursor %d', self.current, self.line_in_current, self.cursor)

	def ReturnCursorToScreen(self):
		"""This routine assumes that either match pattern has been added or removed. It moves
		the cursor to a position that is as close to its previous position as possible before
		adding/removing match pattern"""
		if Log.enabled: Log.screen.debug('Asked to return cursor to the screen')
		new_cursor = 0
		step = 0
		while True:
			line = self.cursor + step
			new_cursor = self.buffer.PrevLineToCurrent(line)
			if new_cursor == -1:
				line = self.cursor - step
				if line < 0:
					new_cursor = 0
					break
				new_cursor = self.buffer.PrevLineToCurrent(line)
				if new_cursor != -1:
					break
			else:
				break
				
			step += 1
			
		self.cursor = new_cursor
		self.mediate_cursor_position = True
		
		if Log.enabled: Log.screen.debug('After returning cursor to screen, cursor at %d', self.cursor)
	
	def ReshuffleMarks(self):
		self.marks = []
		for mark in self.real_marks:
			line = self.buffer.RawToLine(mark)
			if line != -1:
				self.marks.append(line)

	def HideMatching(self):
		ret, special_enter = self.SpawnEdit('Hide matching: ')
		if ret == '':
			return

		if Log.enabled: Log.search.info('Asked to hide matching %s', ret)
		
		self.fix_current_position = True
		self.StartProgress()
		
		self.buffer.hide_patterns.append(ret)
		self.buffer.PostProcessPatternChange()
		self.ReturnCursorToScreen()
		self.ReshuffleMarks()
		
	def ShowMatching(self):
		ret, special_enter = self.SpawnEdit('Show matching: ')
		if ret == '':
			return

		if Log.enabled: Log.search.info('Asked to show matching %s', ret)
		
		self.StartProgress()
		
		self.buffer.match_patterns.append(ret)
		self.buffer.PostProcessPatternChange()
		self.ReturnCursorToScreen()
		self.ReshuffleMarks()
		
	def ClearSelectedShowMatching(self):
		"""This routine presents a menu that allows to manipulate match patterns"""

		if len(self.buffer.match_patterns) == 0:
			self.MessageBox('There are no match patterns to manipulate')
			return
		
		while True:
			lst1 = ['Edit Selected Match Pattern', 'Delete Selected Match Pattern', 'Delete All Match Patterns']
			menu = Menu(self.scr, self, lst1, False, 'Match pattern operations')
			result = menu.Draw()

			if result in [0, 1]:
				self.RedrawScreen()

				if len(self.buffer.match_patterns) == 1:
					subresult = 0
				else:
					submenu = Menu(self.scr, self, self.buffer.match_patterns, False, 'Choose match pattern to edit')
					subresult = submenu.Draw()

				if subresult == None:
					self.RedrawScreen()
					continue
			
			if result == 0:
				ret, special_enter = self.SpawnEdit('Show matching: ', self.buffer.match_patterns[subresult])
				if ret != '':
					self.buffer.match_patterns[subresult] = ret
				break
			elif result == 1:
				del self.buffer.match_patterns[subresult]
			elif result == 2:
				self.buffer.match_patterns = []
			break

		if result != None:
			self.StartProgress()
			self.buffer.PostProcessPatternChange()

			self.ReturnCursorToScreen()
			self.ReshuffleMarks()

	def SpawnEdit(self, prompt, value = ''):
		ret = None
		
		self.editbox = EditBox(self, self.scr, prompt, self.history_list, value)
		ret, special_enter = self.editbox.Run()
		self.editbox = None

		self.RedrawScreen()
		if ret != '':
			self.history_list.append(ret)

		return ret, special_enter
		
	def ClearSelectedHideMatching(self):
		"""This routine presents a menu that allows to manipulate hide patterns"""

		if len(self.buffer.hide_patterns) == 0:
			self.MessageBox('There are no hide patterns to manipulate')
			return

		while True:
			lst1 = ['Edit Selected Hide Pattern', 'Delete Selected Hide Pattern', 'Delete All Hide Patterns']
			menu = Menu(self.scr, self, lst1, False, 'Hide pattern operations')
			result = menu.Draw()

			if result in [0, 1]:
				self.RedrawScreen()

				if len(self.buffer.hide_patterns) == 1:
					subresult = 0
				else:
					submenu = Menu(self.scr, self, self.buffer.hide_patterns, False, 'Choose hide pattern to edit')
					subresult = submenu.Draw()

				if subresult == None:
					self.RedrawScreen()
					continue

			if result == 0:
				ret, special_enter = self.SpawnEdit('Hide matching: ', self.buffer.hide_patterns[subresult])
				if ret != '':
					self.buffer.hide_patterns[subresult] = ret
				break
			elif result == 1:
				del self.buffer.hide_patterns[subresult]
			elif result == 2:
				self.buffer.hide_patterns = []
			break

		if result != None:
			self.StartProgress()
			self.buffer.PostProcessPatternChange()

			self.ReturnCursorToScreen()
			self.ReshuffleMarks()

	def ShowHelpScreen(self, help):
		i = 0
		lines = help.splitlines()
		if len(lines) >= self.text_height:
			raise Exception('The screen is too small for help screen')

		for line in lines:
			txt = line
			txt += ' ' * (self.width - len(line))
			self.brush.DrawLine(i, 0, [txt], [])
			i += 1
			
		while i < self.text_height - Config.STATUS_BAR_HEIGHT:
			txt = ' ' * self.width
			self.brush.DrawLine(i, 0, [txt], [])
			i += 1
			
		txt = 'Press any key to continue'.center(self.width)
		self.brush.DrawLine(i, 0, [txt], [])
		txt = ' ' * self.width
		self.brush.DrawLine(i + 1, 0, [txt], [])
		
		self.brush.DrawLine(self.text_height, 0, ['-' * self.width], [])
	
		self.scr.noutrefresh()
		curses.doupdate()
		
		self.ReadInput()

	def ShowInventory(self):
		i = 0

		self.brush.DrawLine(i, 0, [' ' * self.width], [])
		i += 1
		
		# Search patterns...
		txt = '    Search Patterns:'
		txt += ' ' * (self.width - len(txt))
		self.brush.DrawLine(i, 0, [txt], [])
		i += 1
		
		search_colors = ['Current search', 'Red slot', 'Green slot', 'Blue slot']
		for search_index, search in enumerate(self.searches):
			if self.searches[search_index] == None:
				txt = '        Search %d (%s): None' % (search_index, search_colors[search_index])
				txt = txt.ljust(self.width)
			else:
				if search.direction == HLess.SEARCH_DIRECTION_DOWN:
					dire = 'Down'
				else:
					dire = 'Up'
				txt = '        Search %d (%s) Direction: %s, Pattern: %s' % (search_index, search_colors[search_index], \
					dire, self.searches[search_index].pattern)
				txt = txt.ljust(self.width)
			self.brush.DrawLine(i, 0, [txt], [])
			i += 1

		self.brush.DrawLine(i, 0, [' ' * self.width], [])
		i += 1
		
		# Matching patterns...
		txt = '    Matching patterns:'
		txt += ' ' * (self.width - len(txt))
		self.brush.DrawLine(i, 0, [txt], [])
		i += 1
		for pat in self.buffer.match_patterns:
			txt = '        ' + pat
			txt += ' ' * (self.width - len(txt))
			self.brush.DrawLine(i, 0, [txt], [])
			i += 1
			if i >= self.text_height:
				break
				
		self.brush.DrawLine(i, 0, [' ' * self.width], [])
		i += 1

		# Hide patterns...
		txt = '    Hide patterns:'
		txt += ' ' * (self.width - len(txt))
		self.brush.DrawLine(i, 0, [txt], [])
		i += 1
		
		for pat in self.buffer.hide_patterns:
			txt = '        ' + pat
			txt += ' ' * (self.width - len(txt))
			self.brush.DrawLine(i, 0, [txt], [])
			i += 1
			if i >= self.text_height:
				break

		# Empty lines...
		while i < self.text_height - Config.STATUS_BAR_HEIGHT:
			txt = ' ' * self.width
			self.brush.DrawLine(i, 0, [txt], [])
			i += 1

		txt = 'Press any key to continue'.center(self.width)
		self.brush.DrawLine(i, 0, [txt], [])
		txt = ' ' * self.width
		self.brush.DrawLine(i + 1, 0, [txt], [])
	
		self.scr.noutrefresh()
		curses.doupdate()

		self.ReadInput()
		
	def JumpToNextMark(self):
		indx = 0
		while indx < len(self.marks):
			if self.marks[indx] > self.cursor:
				break
			indx += 1 

		if indx >= len(self.marks):
			self.MessageBox('No more marks left')
		else:
			self.cursor = self.marks[indx]
			self.mediate_cursor_position = True
		
	def JumpToPrevMark(self):
		indx = len(self.marks) - 1
		while indx >= 0:
			if self.marks[indx] < self.cursor:
				break
			indx -= 1

		if indx < 0:
			self.MessageBox('No more marks left')
		else:
			self.cursor = self.marks[indx]
			self.mediate_cursor_position = True

	def ShowSearchSetMenu(self):
		lst1 = ['Push current search', 'Force push current search', 'Pop selected search', 'Exchange current and selected search', \
				'Delete selected search', 'Delete all searches']

		while True:
			menu = Menu(self.scr, self, lst1, False, 'Search patterns operations')
			result = menu.Draw()

			self.RedrawScreen()

			if result == 0:
				pushed = False
				for i in range(1, 4):
					if self.searches[i] == None:
						self.searches[i] = self.searches[0]
						self.searches[0] = None
						pushed = True
						break

				if not pushed:
					self.MessageBox('There are no empty search set slots')
					continue

				break

			if result in range(1, 5):
				lst2 = []
				slots = ['Red', 'Green', 'Blue']
				for slot_index in range(1, 4):
					if self.searches[slot_index] != None:
						lst2.append(slots[slot_index - 1] + ' slot: ' + self.searches[slot_index].pattern)
					else:
						lst2.append(slots[slot_index - 1] + 'Red slot: None')
				submenu = Menu(self.scr, self, lst2, False, 'Select search slot')
				subresult = submenu.Draw()

				if subresult == None:
					continue
				subresult += 1

			if result == 1:
				self.searches[subresult] = self.searches[0]
				self.searches[0] = None
			elif result == 2:
				self.searches[0] = self.searches[subresult]
				self.searches[subresult] = None
			elif result == 3:
				temp = self.searches[subresult]
				self.searches[subresult] = self.searches[0]
				self.searches[0] = temp
			elif result == 4:
				self.searches[subresult] = None
			elif result == 5:
				self.searches[1] = None
				self.searches[2] = None
				self.searches[3] = None

			break
		
	def CheckInput(self):
		self.scr.timeout(500)
		c = self.scr.getch()
		self.scr.timeout(-1)
		if c == -1:
			return None
		return c
		
	def ProcessInput(self, c):
		if Log.enabled: Log.keys.info('Received %s', KeyName(c))
		try:
			if c == curses.KEY_DOWN:
				if not self.tail_mode:
					self.HandleKeyDown()
			elif c == curses.KEY_UP:
				if not self.tail_mode:
					self.HandleKeyUp()
			elif c == curses.KEY_NPAGE:
				if not self.tail_mode:
					self.HandlePagedown()
			elif c == curses.KEY_PPAGE:
				if not self.tail_mode:
					self.HandlePageup()
			elif c == ord(' '):
				self.ToggleMark()
			elif c == ord('/'):
				self.DoSearch(c)				
			elif c == ord('?'):
				self.DoSearch(c)				
			elif c == ord('q'):
				self.done = True
			elif c == ord('n'):
				if not self.tail_mode:
					if self.searches[0] != None:
						if self.searches[0].direction == HLess.SEARCH_DIRECTION_DOWN:
							self.FindNextSearchMatch(self.searches[0])
						elif self.searches[0].direction == HLess.SEARCH_DIRECTION_UP:
							self.FindPrevSearchMatch(self.searches[0])
			elif c == ord('N'):
				if not self.tail_mode:
					if self.searches[0] != None:
						if self.searches[0].direction == HLess.SEARCH_DIRECTION_DOWN:
							self.FindPrevSearchMatch(self.searches[0])
						elif self.searches[0].direction == HLess.SEARCH_DIRECTION_UP:
							self.FindNextSearchMatch(self.searches[0])
			elif c == ord('.'):
				self.JumpToNextMark()
			elif c == ord('>'):
				self.JumpToPrevMark()
			elif c == ord(':'):
				if not self.tail_mode:
					self.HandleColon()
			elif c == ord('g'):
				if not self.tail_mode:
					self.cursor = 0
					self.current = 0
			elif c == ord('G'):
				if not self.tail_mode:
					self.GotoEOF()
			elif c == ord('s'):
				self.ShowMatching()
			elif c == ord('S'):
				self.ClearSelectedShowMatching()
			elif c == ord('d'):
				self.HideMatching()
			elif c == ord('D'):
				self.ClearSelectedHideMatching()
			elif c == ord('l'):
				if self.show_line_numbers:
					self.show_line_numbers = False
				else:
					self.show_line_numbers = True
			elif c == ord('h'):
				global help
				self.ShowHelpScreen(help)
			elif c == ord('i'):
				self.ShowInventory();
			elif c == ord('t'):
				if self.tail_mode:
					self.tail_mode = False
				else:
					self.MessageBox('Press t to leave tail mode')
					self.tail_mode = True
			elif c == ord('Z'):
				if Log.enabled:
					Log.keys.info('Disabled logs')
					Log.enabled = False
					self.MessageBox('Disabled logs')
				else:
					ret, special_enter = self.SpawnEdit('Debug Groups (space separated): ')
					Log.debug_groups = ret.split(' ')
					Log.enabled = True
					SetupLogs()
					Log.keys.info('Enabled logs')
					self.MessageBox('Enabled logs')	
			elif c == ord('~'):
				self.searches[0] = None
			elif c == ord('F'):
				if self.searches[0] != None:
					if self.searches[0].direction == HLess.SEARCH_DIRECTION_DOWN:
						self.searches[0].direction = HLess.SEARCH_DIRECTION_UP
					elif self.searches[0].direction == HLess.SEARCH_DIRECTION_UP:
						self.searches[0].direction = HLess.SEARCH_DIRECTION_DOWN
			elif c == ord('\\'):
				self.ShowSearchSetMenu()
			elif c in [ord('1'), ord('2'), ord('3')]:
				if not self.tail_mode:
					pat = c - 48
					if self.searches[pat] != None:
						if self.searches[pat].direction == HLess.SEARCH_DIRECTION_DOWN:
							self.FindNextSearchMatch(self.searches[pat])
						elif self.searches[pat].direction == HLess.SEARCH_DIRECTION_UP:
							self.FindPrevSearchMatch(self.searches[pat])
			elif c in [ord('!'), ord('@'), ord('#')]:
				if not self.tail_mode:
					dict = {}
					dict[ord('!')] = 1
					dict[ord('@')] = 2
					dict[ord('#')] = 3
					pat = dict[c]
					if self.searches[pat] != None:
						if self.searches[pat].direction == HLess.SEARCH_DIRECTION_DOWN:
							self.FindPrevSearchMatch(self.searches[pat])
						elif self.searches[pat].direction == HLess.SEARCH_DIRECTION_UP:
							self.FindNextSearchMatch(self.searches[pat])
			elif c == ord('X'):
				pass

		except KeyboardInterrupt:
			if Log.enabled: Log.keys.info('Interrupted from keyboard')
			self.mediate_cursor_position = True
			
		self.StopProgress()

		if Log.enabled: Log.keys.info('After processing %s, current - %d.%d, cursor - %d', KeyName(c), self.current, \
			self.line_in_current, self.cursor)

	def Main(self):
		self.status_bar.Draw()
		
		while not self.done:
			if Log.enabled: Log.main.info('==================================================================================================')
				
			if self.tail_mode:
				self.buffer.ResetEof()
				self.GotoEOF()
				
			self.RedrawScreen()
			
			if Log.enabled: Log.main.info('--------------------------------------------------------------------------------------------------')

			if self.tail_mode:
				c = self.CheckInput()
			else:
				c = self.ReadInput()
			self.ProcessInput(c)
				
		self.StopProgress()

def CursesMain(scr):
	global hless
	
	try:
		hless = HLess(scr, Config.file)
		hless.Main()
	except KeyboardInterrupt:
		raise
		
def Main():
	try:
		ParseCommandLine()
	except:
		sys.exit(-1)
	SetupSystem()
	curses.wrapper(CursesMain)

if __name__ == '__main__':
	Main()

